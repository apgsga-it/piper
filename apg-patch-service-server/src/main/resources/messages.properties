SimplePatchContainerBean.listMavenArtifacts.error=Exception: <{0}> in listMavenArtifacts  for Patch : {1}
SimplePatchContainerBean.addModuleName.validation.error=Patch cannot be saved as it contains module(s) with invalid name: {0} 
SimplePatchContainerBean.addModuleName.exception=Exception: <{0}> adding Module: {1} to Branch: {2}
SimplePatchContainerBean.getArtifactsWithNameFromBom.exception=Exception: <{0}> when trying to get Artifact name from Bom for version: {1} 
SimplePatchContainerBean.getArtifactNameError.exception=Exception: <{0}> while checking Artifact name {1} for being valid cvs module
SimplePatchContainerBean.save.patchobject.notnull.assert=Patch object null for save
SimplePatchContainerBean.save.patchnumber.notnullorempty.assert=Patch number null or empty for save of Patch : {0}
SimplePatchContainerBean.remove.patchobject.notnull.assert=Patch object null for remove
SimplePatchContainerBean.remove.patchnumber.notnullorempty.assert=Patch number null or empty for save of Patch : {0}
SimplePatchContainerBean.remove.patch.exists.assert=Patch: {0} to remove not found 
SimplePatchContainerBean.listAllObjectsChangedForDbModule.patch.exists.assert=Patch: {0} to listAllObjectsChangedForDbModule not found
SimplePatchContainerBean.addPackagerName.packagerName.notnull=Service {0} has not been define within ServicesMetadata.json, or package name property is missing 
SimplePatchContainerBean.startInstallPipeline.patchobject.notnull.assert=Patch object null for startInstallPipeline
SimplePatchContainerBean.startInstallPipeline.patchnumber.notnull.assert=Patch number null for startInstallPipeline of Patch : {0}
SimplePatchContainerBean.startInstallPipeline.patch.exists.assert=Patch: {0} to startInstallPipeline not found 
SimplePatchContainerBean.restartProdPipeline.patchnumber.notnull.assert=Patchnumber null for restartProdPipeline
SimplePatchContainerBean.restartProdPipeline.patch.exists.assert=Patch with Patchnumber: {0} to restartProdPipeline not found
SimplePatchContainerBean.restartProdPipeline.patch.alreadyRunning=Patch {0} can not be restarted as he is already running
SimplePatchContainerBean.restartProdPipeline.patch.lastBuildInErrorOrAborted=Patch {0} can not be restarted as the last build did not end with an error or has not been aborted
SimplePatchContainerBean.copyPatchFile.exception=Error while copying Patch file to {0}
SimplePatchContainerBean.log.patch.not.exist=Cannot log patch info because the following patch doe not exists: {0}
SimplePatchContainerBean.log.patchnumber.isnullorempty=Cannot log patch info for null or empty patch number
SimplePatchContainerBean.log.patch.null.assert=Cannot log patch info for null patch object
SimplePatchContainerBean.build.patch.exists.assert=Cannot build Patch {0} as it does not exist.
SimplePatchContainerBean.build.target.notnull=Cannot build Patch {0} for a null or empty a null target.
SimplePatchContainerBean.patch.exists.assert=Patch with number: {0} for setup not found 
PipelineInputAction.patch.exists.assert=Patch with number: {0} for toState Action {1} not found 
PipelineInputAction.stage.exists.assert=Corresponding stage not found for Action {0}
AtomicFileWriteManager.write.exception=Exception: <{0}> while atomic write to File {2} of: {1} 
FilebasedPatchPersistence.save.patchobject.notnull.assert=Patch object null for save
FilebasedPatchPersistence.save.patchlog.patch.notnull.assert=PatchLog cannot be saved as corresponding patch object is null 
FilebasedPatchPersistence.save.patchnumber.notnullorempty.assert=Patch number null or empty for save of Patch : {0}
FilebasedPatchPersistence.save.patchlognumber.notnullorempty.assert=Patch number null or empty for save of PatchLog : {0}
FilebasedPatchPersistence.patchExists.patchnumber.notnullorempty.assert=Patch number null for empty for findById
FilebasedPatchPersistence.findById.patchnumber.notnullorempty.assert=Patch number null for empty for findById
FilebasedPatchPersistence.findById.patchlognumber.notnullorempty.assert=Patch number null or empty for findPatchLogById
FilebasedPatchPersistence.save.patchlog.null.loginfo=Cannot log patch information for null patchLogDetails object
FilebasedPatchPersistence.findById.exception=Persistance Exception  : <{0}> for findById for Patchnumber: {1}
FilebasedPatchPersistence.patchExists.exception=Persistance Exception : <{0}> for patchExists for Patchnumber:  {0}
FilebasedPatchPersistence.findAllPatchIds.exception=Persistence Exception : <{0}> retrieving all Patch Ids
FilebasedPatchPersistence.removePatch.exception=Persistence Exception : <{0}>  removing Patch {1} 
FilebasedPatchPersistence.getServicesMetaData.exception=Persistence Exception : <{0}> retrieving ServicesMetaData Configuration file
FilebasedPatchPersistence.onDemandTargets.exception=Persistence Exception : <{0}> retrieving onDemandTargets Configuration file 
FilebasedPatchPersistence.stageMapping.exception=Persistence Exception : <{0}> retrieving stageMapping Configuration file
FilebasedPatchPersistence.targetInstance.exception=Persistence Exception : <{0}> retrieving targetSystem Configuration file
FilebasedPatchPersistence.servicemetadata.exception=Persistence Exception : <{0}> retrieving servicesMetadata Configuration file
FilebasedPatchPersistence.getDbModules.exception=Persistence Exception : <{0}> retrieving DbModules Configuration file
FilebasedPatchPersistence.listAllFiles.exception=Persistence Exception : <{0}> on listing all Persistent Files
FilebasedPatchPersistence.listFiles.exception=Persistence Exception : <{0}>  on listing all Persistent Files with Prefix {1}
FilebasedPatchPersistence.writeToFile.exception=Persistence Exception : <{0}>  on Json Conversation before writing to file {1}
FilebasedPatchPersistence.findServiceByName.assert=Persistence Exception : ServiceMetaData not consistent
JschCommandRunner.preProcess.exception=Exception : <{0}>  Jsch connecting to host: {1}
JschCommandRunner.run.exception=Exception : <{0}>  running remote ssh command {1} 
JenkinsPatchClientImpl.createPatchPipelines.error=Creating the Patch Pipelines in Jenkins failed for Patch {0} with {1} 
JenkinsPatchClientImpl.createPatchPipelines.exception=Exception: <{0}> while starting the Jenkins Pipeline Creation Job for Patch:  {1} 
JenkinsPatchClientImpl.startPipeline.error=Starting the Patch Pipeline Job: ${0} in Jenkins failed for Patch: {1} with output: {2} 
JenkinsPatchClientImpl.inputActionForPipeline.error=Jenkins Input Action : {1} for Patch Pipeline Job for Patch: {0} not found
JenkinsPatchClientImpl.processInputAction.exception=Exception: <{0}> while processing Jenkins Input Action for Patch:  {1}
JenkinsPatchClientImpl.triggerPipelineJobAndWaitUntilBuilding.error="Could'nt Trigger Job: {0} and wait until Building"
JenkinsPatchClientImpl.triggerPipelineJobWithoutWaitingOnFeedback.exception=Exception: <{0}> while trying to start following Job: {1}
InstallTargetsUtil.listInstallTargets.exception=Exception: <{0}> while listing Installation Targets from File:  {1} 
Groovy.script.executePatchAction.configdir.exists.assert=Config Dir {0} does not exist for Patch: {2} and to {0}
Groovy.script.executePatchAction.configfile.exists.assert=Config File {0} does not exist for Patch: {2} and to {0}
JenkinsAdminClientImpl.startPipeline.error=Starting onClone pipeline failed for target {0}
JenkinsPatchClientImpl.isProdPipelineForPatchRunning.error=Could not determine if patch {0} is already running
JenkinsPatchClientImpl.getProdPipelineBuildResult.error=Could not get BuildResult of last build for patch {0}
JenkinsPatchClientImpl.startAssembleAndDeployPipeline.error=Error while starting assembleAndDeploy Pipeline for target {0}. Exception: {1}
JenkinsPatchClientImpl.startInstall.error=Error while starting install Pipeline for target {0}. Exception: {1}
JenkinsSshCommand.startJobWithFileParam.windows.error=Starting a Jenkins Job with a file parameter is nut supported under Windows.